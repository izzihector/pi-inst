function numFormatter(num, digits) {
    var number = Math.abs(num);
    var sign = Math.sign(num);
    if(number < 1000){
        if (Number.isInteger(number)){
            return number * sign;
        } else {
            var result = (number * sign).toFixed(digits).toString().substring(0,digits)
            if (result[result.length - 1] == '.'){
                return result.slice(0, -1);
            }
            return result;
        }
    } else {
        if (number < 1000000){
            var div = 1000;
            var unit = 'K';
        } else if (number < 1000000000){
            var div = 1000000;
            var unit = 'M';
        } else if (number < 1000000000000){
            var div = 1000000000;
            var unit = 'B'
        }
        var result = (number / div * sign).toFixed(digits).toString().substring(0,digits);
        if (result[result.length - 1] == '.'){
            return result.slice(0, -1) + unit;
        }
        return result + unit;
    }
};
function getQuarterStartDate(today){
    var quarter = parseInt((today.getMonth() - 1) / 3) + 1;
    return new Date(today.getFullYear(), (quarter * 3), 1);
};
(function () {
	if (!window.Chart) {
		return;
	}
	function GaugeChartHelper() {
	}
	GaugeChartHelper.prototype.setup = function(chart, config) {
		this.chart = chart;
		this.ctx = chart.ctx;
		this.limits = config.data.datasets[0].gaugeLimits;
		this.data = config.data.datasets[0].gaugeData;
		var options = chart.options;
		this.fontSize = options.defaultFontSize;
		this.fontStyle = options.defaultFontFamily;
		this.fontColor = options.fontColor;
		this.gaugeLayout = options.gaugeLayout;
		var gaugeLayoutArray = options.gaugeLayout.split('_');
		this.layoutIndex = gaugeLayoutArray[gaugeLayoutArray.length - 1];
		this.arrowAnimation = options.arrowAnimation;
		this.labelUnit = options.labelUnit;
		this.decimalPrecision = options.gaugeDP;
		this.limitPercent = options.limitPercent;
		this.dateSelection = options.dateSelection;
		this.gaugeColors = options.gaugeColors;
		this.showMinMaxOnly = options.showMinMaxOnly;
		this.ctx.textBaseline = "alphabetic";
		this.arrowAngle = 25 * Math.PI / 180;
		this.arrowColor = options.arrowColor || config.options.indicatorColor;
		this.showMarkers = typeof(config.options.showMarkers) === 'undefined' ? true : config.options.showMarkers;
		if (config.options.markerFormatFn) {
			this.markerFormatFn = config.options.markerFormatFn;
		} else {
			this.markerFormatFn = function(value) {
				return value;
			}
		}
        if(screen.width<480){
            this.fontSize = 12;
        } else if(screen.width<1440){
            this.fontSize = 18;
        } else{
            this.fontSize = 20;
        }
	};
	GaugeChartHelper.prototype.applyGaugeConfig = function(chartConfig) {
        // show pie chart in layout_4
        if (this.layoutIndex == '4'){
            chartConfig.options.circumference = Math.PI * 2;
        }
		this.calcLimits();
		chartConfig.data.datasets[0].data = this.doughnutData;
		var ctx = this.ctx;
		var labelsWidth = this.limits.map(function(label){
			var text = this.markerFormatFn(label);
			return ctx.measureText(text).width;
		}.bind(this));
	};
	GaugeChartHelper.prototype.calcLimits = function() {
		var limits = this.limits;
		var data = [];
		var total = 0;
		for (var i = 1, ln = limits.length; i < ln; i++) {
			var dataValue = Math.abs(limits[i] - limits[i - 1]);
			total += dataValue;
			data.push(dataValue);
		}
		this.doughnutData = data;
		var minValue = limits[0];
		var maxValue = limits[limits.length - 1];
		this.isRevers = minValue > maxValue;
		this.minValue = this.isRevers ? maxValue : minValue;
		this.totalValue = total;
	};
	GaugeChartHelper.prototype.updateGaugeDimensions = function() {
		var chartArea = this.chart.chartArea;
		this.gaugeRadius = this.chart.innerRadius;
		this.outerRadius = this.chart.outerRadius;
		this.gaugeCenterX = (chartArea.left + chartArea.right) / 2;
		this.gaugeCenterY = (chartArea.top + chartArea.bottom + this.chart.outerRadius) / 2;
		this.arrowLength = 20;
	};
	GaugeChartHelper.prototype.getCoordOnCircle = function(r, alpha) {
		return {
			x: r * Math.cos(alpha),
			y: r * Math.sin(alpha)
		};
	};
	GaugeChartHelper.prototype.getAngleOfValue = function(value) {
		var result = 0;
		var gaugeValue = value - this.minValue;
		if (gaugeValue <= 0) {
			result = 0;
		} else if (gaugeValue >= this.totalValue) {
			result = Math.PI;
		} else {
			result = Math.PI * gaugeValue / this.totalValue;
		}
		if (this.isRevers) {
			return Math.PI - result;
		} else {
			return result;
		}
	};
	GaugeChartHelper.prototype.getAngleOfValueFull = function(value) {
		var result = 0;
		var gaugeValue = value - this.minValue;
		if (gaugeValue <= 0) {
			result = 0;
		} else if (gaugeValue >= this.totalValue) {
			result = Math.PI * 2;
		} else {
			result = Math.PI * 2 * gaugeValue / this.totalValue;
		}
		if (this.isRevers) {
			return Math.PI * 2 - result;
		} else {
			return result;
		}
	};
	GaugeChartHelper.prototype.renderLimitLabel = function(value) {
		var ctx = this.ctx;
		var angle = this.getAngleOfValue(value);
		if(screen.width<768){
            var coord = this.getCoordOnCircle(this.chart.outerRadius * 1.15 , angle);
        } else{
            // make the limit label closer to the gauge
            var coord = this.getCoordOnCircle(this.chart.outerRadius * 1.1 , angle);
        }
		var align;
		var diff = angle - (Math.PI / 2);
		if (diff > 0) {
			align = "left";
		} else if (diff < 0) {
			align = "right";
		} else {
			align = "center";
		}
		ctx.textAlign = align;
		// font size ratio to the screen
		ctx.font = "bold " + this.fontSize + "px " + this.fontStyle;
		ctx.fillStyle = this.fontColor;
        var text = numFormatter(value, this.decimalPrecision) + " " + this.labelUnit;
		ctx.fillText(text, this.gaugeCenterX - coord.x, this.gaugeCenterY - coord.y);
	};
    GaugeChartHelper.prototype.renderLimitLabelMinMax = function(index, value) {
		var ctx = this.ctx;
		var align = 'center';
		if (index == 0){
		    var position_x = this.gaugeCenterX - this.chart.outerRadius;
		    var position_y = this.gaugeCenterY + 10;
		} else {
		    var position_x = this.gaugeCenterX + this.chart.outerRadius;
            var position_y = this.gaugeCenterY + 10;
		}
		ctx.textAlign = align;
		// font size ratio to the screen
		ctx.font = "bold " + this.fontSize + "px " + this.fontStyle;
		ctx.fillStyle = this.fontColor;
        var text = numFormatter(value, this.decimalPrecision) + " " + this.labelUnit;
		ctx.fillText(text, position_x , position_y);
	};
	GaugeChartHelper.prototype.renderLimits = function() {
        // special logic for layout 4
        if (this.layoutIndex == '4'){
            // get the chart area
            var chartArea = this.chart.chartArea;
            // get center X and Y of chartArea
            var centerX = (chartArea.left + chartArea.right) / 2;
            var centerY = (chartArea.top + chartArea.bottom) / 2;
            var ctx = this.ctx;
            // get the count of won lead and lost lead
            var won_count = this.limits[1];
	        var lost_count = this.limits[2] - this.limits[1];
	        // compute the percentage of won and lost
	        var won_percentage = (won_count / (won_count + lost_count) * 100).toFixed(0);
	        var lost_percentage = (lost_count / (won_count + lost_count) * 100).toFixed(0);
	        // compute the correct angle of won segment and lost segment
	        // have to divide the angle by 2, to place the label in the middle
	        // computation of lost_angle should consider the won_angle
	        var won_angle = this.getAngleOfValueFull(won_count) * 0.5;
	        var lost_angle = this.getAngleOfValueFull(lost_count) * 0.5 + won_angle * 2;
	        // get the coordination of won and lost in the chart
	        // if the angle of the segment is lower than certain point, then
	        // make it outlabel.
	        if (won_angle < (Math.PI * 0.15)){
	            if(screen.width<1440){
	                var won_coord = this.getCoordOnCircle(this.chart.outerRadius * 1.15, won_angle);
	            } else {
	                var won_coord = this.getCoordOnCircle(this.chart.outerRadius * 1.2, won_angle);
	            }
	        } else {
	            var won_coord = this.getCoordOnCircle(this.chart.outerRadius * 0.5, won_angle);
	        }
	        if (lost_angle > (Math.PI * 1.85)){
	            if(screen.width<1440){
	                var lost_coord = this.getCoordOnCircle(this.chart.outerRadius * 1.15, lost_angle);
	            } else {
	                var lost_coord = this.getCoordOnCircle(this.chart.outerRadius * 1.2, lost_angle);
	            }
	        } else {
	            var lost_coord = this.getCoordOnCircle(this.chart.outerRadius * 0.5, lost_angle);
	        }

	        if (won_count){
	            // if won_count is not zero and lost_count is zero, then place
	            // the label in the middle of the circle
	            if (lost_count == 0){
                    ctx.beginPath();
                    ctx.textAlign = 'center';
                    ctx.font = "bold " + this.fontSize + "px " + this.fontStyle;
                    ctx.fillStyle = 'black';
                    ctx.textBaseline = "bottom";
                    ctx.fillText(won_percentage + '%', centerX, centerY);
                    ctx.textBaseline = "top";
                    ctx.fillText('Won', centerX, centerY);
                    ctx.closePath();
	            } else {
                    ctx.beginPath();
                    ctx.textAlign = 'center';
                    ctx.font = "bold " + this.fontSize + "px " + this.fontStyle;
                    ctx.fillStyle = 'black';
                    ctx.textBaseline = "bottom";
                    ctx.fillText(won_percentage + '%', centerX - won_coord.x, centerY - won_coord.y);
                    ctx.textBaseline = "top";
                    ctx.fillText('Won', centerX - won_coord.x, centerY - won_coord.y);
                    ctx.closePath();

	            }
	        }
	        if (lost_count){
	            // if lost_count is not zero and won_count is zero, then place
	            // the label in the middle of the circle
	            if (won_count == 0){
                    ctx.beginPath();
                    ctx.textAlign = 'center';
                    ctx.font = "bold " + this.fontSize + "px " + this.fontStyle;
                    ctx.fillStyle = 'black';
                    ctx.textBaseline = "bottom";
                    ctx.fillText(lost_percentage + '%', centerX, centerY);
                    ctx.textBaseline = "top";
                    ctx.fillText('Lost', centerX, centerY);
                    ctx.closePath();
	            } else {
	                ctx.beginPath();
                    ctx.textAlign = 'center';
                    ctx.font = "bold " + this.fontSize + "px " + this.fontStyle;
                    ctx.fillStyle = 'black';
                    ctx.textBaseline = "bottom";
                    ctx.fillText(lost_percentage + '%', centerX - lost_coord.x, centerY - lost_coord.y);
                    ctx.textBaseline = "top";
                    ctx.fillText('Lost', centerX - lost_coord.x, centerY - lost_coord.y);
                    ctx.closePath();
	            }
	        }
        } else {
            for (var i = 0, ln = this.limits.length; i < ln; i++) {
                // skip the limits between min and max if the showMinMaxonly is true
                if (this.showMinMaxOnly && i!=0 && i!= ln-1){
                    continue;
                }
                if ((i!=0 && i!=ln-1) || screen.width>=1440){
                    this.renderLimitLabel(this.limits[i]);
                } else {
                    this.renderLimitLabelMinMax(i, this.limits[i]);
                }
            }
        }

	};
	GaugeChartHelper.prototype.renderValueLabel = function() {
	    var ctx = this.ctx;
	    // get the full value label
	    var label = this.labelUnit;
	    var data_value = numFormatter(this.data.value, this.decimalPrecision);
	    var final_value = data_value;
	    // render value label for win loss ratio
	    if (this.layoutIndex == '4'){
	        // get the won and lost count
	        var won_count = this.limits[1];
	        var lost_count = this.limits[2] - this.limits[1];
	        // implement this logic to avoid infinity value
	        if (lost_count){
	            var ratio = won_count/lost_count;
	            // prettify the value label
	            if (ratio % 1 == 0){
	                var final_value = ratio + ' : 1';
	            } else {
	                var final_value = numFormatter(ratio, 4) + ' : 1';
	            }
	        } else {
	            var final_value = won_count + ' : 0';
	        }
	        // don't show ratio on the top left of win loss ratio chart
	        var final_value = "";
	    }
	    if (label) {
	        var final_value = data_value + " " + label;
	    }
	    // always render value on top left
	    var fontSizeRatio = 0.07;
        var fontSize = this.ctx.canvas.clientWidth * fontSizeRatio;
        var x_position = 3;
        var y_position = 3;
        ctx.beginPath();
        ctx.font = "bold " + fontSize + "px " + this.fontStyle;
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
        ctx.fillStyle = this.data.valueColor || this.fontColor;
        // write text at top left of chart
        ctx.fillText(final_value, x_position, y_position);
        ctx.closePath();
	};
	GaugeChartHelper.prototype.renderValueArrow = function(value) {
		var angle = this.getAngleOfValue(typeof value === "number" ? value : this.data.value);
		this.ctx.globalCompositeOperation = "source-over";
		this.renderArrow(this.gaugeRadius, angle, this.arrowLength, this.arrowAngle, this.arrowColor);
	};
	GaugeChartHelper.prototype.renderSmallValueArrow = function(value) {
		var angle = this.getAngleOfValue(value);
		this.ctx.globalCompositeOperation = "source-over";
		this.renderArrow(this.gaugeRadius - 1, angle, this.arrowLength - 1, this.arrowAngle, this.arrowColor);
	};
	GaugeChartHelper.prototype.clearValueArrow = function(value) {
		var angle = this.getAngleOfValue(value);
		this.ctx.lineWidth = 2;
		this.ctx.globalCompositeOperation = "destination-out";
		this.renderArrow(this.gaugeRadius - 1, angle, this.arrowLength + 1, this.arrowAngle, "#FFFFFF");
		this.ctx.stroke();
	};
	GaugeChartHelper.prototype.renderArrow = function(radius, angle, arrowLength, arrowAngle, arrowColor) {
        var ctx = this.ctx;
	    switch (parseInt(this.layoutIndex)) {
	        case 1:
                var coord = this.getCoordOnCircle(radius - 10, angle);
                var arrowPoint = {
                    x: this.gaugeCenterX - coord.x + 2,
                    y: this.gaugeCenterY - coord.y + 2
                };
                ctx.fillStyle = arrowColor;
                ctx.beginPath();
                ctx.moveTo(arrowPoint.x, arrowPoint.y);
                coord = this.getCoordOnCircle(radius * 0.2, angle + arrowAngle);
                ctx.lineTo(arrowPoint.x + coord.x, arrowPoint.y + coord.y);
                coord = this.getCoordOnCircle(radius * 0.2, angle - arrowAngle);
                ctx.lineTo(arrowPoint.x + coord.x, arrowPoint.y + coord.y);
                ctx.closePath();
                ctx.fill();
                break;
            case 2:
                var arrowThicknessRatio = 0.1;
                var arrowLengthRatio = 1.3;
                // needle
                ctx.beginPath();
                ctx.save();
                // change the center point of the canvas
                ctx.translate(this.gaugeCenterX, this.gaugeCenterY);
                // rotate the arrow
                ctx.rotate(angle);
                ctx.moveTo(0, -(this.gaugeRadius * arrowThicknessRatio));
                ctx.lineTo(-(this.gaugeRadius * arrowLengthRatio), 0);
                ctx.lineTo(0, this.gaugeRadius * arrowThicknessRatio);
                ctx.fillStyle = 'black';
                ctx.fill();
                ctx.closePath();
                // center point circle
                ctx.beginPath();
                ctx.arc(0, 0, this.gaugeRadius * arrowThicknessRatio, 0, 2 * Math.PI);
                ctx.fill();
                // translate back to top left
                ctx.translate(-this.gaugeCenterX, -this.gaugeCenterY);
                // rotate back the context
                ctx.rotate(-angle);
                ctx.restore();
                break;
            case 3:
                var coord_1 = this.getCoordOnCircle(this.outerRadius, angle);
                var coord_2 = this.getCoordOnCircle(this.gaugeRadius, angle);
                var arrowPoint_1 = {
                    x: this.gaugeCenterX - coord_1.x + 2,
                    y: this.gaugeCenterY - coord_1.y + 2
                };
                var arrowPoint_2 = {
                    x: this.gaugeCenterX - coord_2.x + 2,
                    y: this.gaugeCenterY - coord_2.y + 2
                };
                ctx.strokeStyle = arrowColor;
                ctx.beginPath();
                ctx.lineWidth = 10;
                ctx.lineCap = 'round'
                ctx.moveTo(arrowPoint_1.x, arrowPoint_1.y);
                ctx.lineTo(arrowPoint_2.x, arrowPoint_2.y);
                ctx.stroke();
                ctx.closePath();
                break;
            case 4:
                break;
            case 5:
                // get the limits array
                var limits = this.limitPercent;
                for (var i = 1; i < limits.length; i++) {
                    ctx.beginPath();
                    ctx.lineWidth = this.gaugeRadius * 0.1;
                    var color = this.gaugeColors[i-1];
                    ctx.strokeStyle = color
                    var start_point = Math.PI + (Math.PI * (limits[i-1] / 100)) || Math.PI;
                    var end_point = Math.PI + (Math.PI * (limits[i] / 100));
                    // draw the arc based on the limit percentage and colors correspond to their position
                    ctx.arc(this.gaugeCenterX, this.gaugeCenterY, this.gaugeRadius * 0.9, start_point , end_point, false);
                    ctx.stroke();
                    ctx.closePath();
                }
                break;
            case 6:
                // this is actual vs target chart
                // get the limits array
                var limits = this.limitPercent;
                for (var i = 1; i < limits.length; i++) {
                    ctx.beginPath();
                    ctx.lineWidth = this.gaugeRadius * 0.1;
                    var color = this.gaugeColors[i-1];
                    ctx.strokeStyle = color
                    var start_point = Math.PI + (Math.PI * (limits[i-1] / 100)) || Math.PI;
                    var end_point = Math.PI + (Math.PI * (limits[i] / 100));
                    // draw the arc based on the limit percentage and colors correspond to their position
                    ctx.arc(this.gaugeCenterX, this.gaugeCenterY, this.gaugeRadius * 0.9, start_point , end_point, false);
                    ctx.stroke();
                    ctx.closePath();
                }
                ctx.fillStyle = this.fontColor;
                // show up to date target
                switch (this.dateSelection){
                    case 't_month':
                        var today = new Date();
                        var today_date = today.getDate();
                        // assume every month has 30 days
                        var maximum_days = today_date > 30? today_date: 30;
                        var date_divide = today_date / maximum_days;
                        // get the angle of the arrow
                        var date_angle = date_divide * Math.PI;
                        // draw arrow
                        var coord = this.getCoordOnCircle(radius * 0.8, date_angle);
                        var arrowPoint = {
                            x: this.gaugeCenterX - coord.x + 2,
                            y: this.gaugeCenterY - coord.y + 2
                        };
                        ctx.beginPath();
                        ctx.moveTo(arrowPoint.x, arrowPoint.y);
                        coord = this.getCoordOnCircle(radius * 0.2, date_angle + arrowAngle);
                        ctx.lineTo(arrowPoint.x + coord.x, arrowPoint.y + coord.y);
                        coord = this.getCoordOnCircle(radius * 0.2, date_angle - arrowAngle);
                        ctx.lineTo(arrowPoint.x + coord.x, arrowPoint.y + coord.y);
                        ctx.fill();
                        ctx.closePath();
                        // draw the up to date target label and value
                        var fontSize = this.fontSize;
                        ctx.beginPath();
                        ctx.font = "bold " + fontSize + "px " + this.fontStyle;
                        ctx.textAlign = "center";
                        ctx.textBaseline = "bottom";
                        if (screen.width>=1440){
                            ctx.fillText('Expected', this.gaugeCenterX, this.gaugeCenterY);
                        } else {
                            ctx.fillText('Expected', this.gaugeCenterX, this.gaugeCenterY + 5);
                        }
                        ctx.closePath();
                        var fontSize = this.fontSize * 1.3;
                        ctx.beginPath();
                        ctx.font = "bold " + fontSize + "px " + this.fontStyle;
                        ctx.textAlign = "center";
                        ctx.textBaseline = "top";
                        var target_value = numFormatter(date_divide * this.limits.slice(-1)[0], this.decimalPrecision);
                        if (screen.width>=1440){
                            ctx.fillText(target_value, this.gaugeCenterX, this.gaugeCenterY);
                        } else {
                            ctx.fillText(target_value, this.gaugeCenterX, this.gaugeCenterY + 5);
                        }
                        ctx.closePath();
                    break;
                    case 't_quarter':
                        var today = new Date();
                        var quarter_start = getQuarterStartDate(today);
                        var diffTime = Math.abs(today - quarter_start);
                        var diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                        // assume every quarter has 90 days
                        var maximum_days = diffDays > 90? diffDays: 90;
                        var quarter_divide = diffDays / maximum_days;
                        // get the angle of the arrow
                        var date_angle = quarter_divide * Math.PI;
                        // draw arrow
                        var coord = this.getCoordOnCircle(radius * 0.8, date_angle);
                        var arrowPoint = {
                            x: this.gaugeCenterX - coord.x + 2,
                            y: this.gaugeCenterY - coord.y + 2
                        };
                        var fontSize = this.fontSize;
                        ctx.beginPath();
                        ctx.moveTo(arrowPoint.x, arrowPoint.y);
                        coord = this.getCoordOnCircle(radius * 0.2, date_angle + arrowAngle);
                        ctx.lineTo(arrowPoint.x + coord.x, arrowPoint.y + coord.y);
                        coord = this.getCoordOnCircle(radius * 0.2, date_angle - arrowAngle);
                        ctx.lineTo(arrowPoint.x + coord.x, arrowPoint.y + coord.y);
                        ctx.fill();
                        ctx.closePath();
                        // draw the up to date target label and value
                        var fontSize = this.fontSize
                        ctx.beginPath();
                        ctx.font = "bold " + fontSize + "px " + this.fontStyle;
                        ctx.textAlign = "center";
                        ctx.textBaseline = "bottom";
                        if (screen.width>=1440){
                            ctx.fillText('Expected', this.gaugeCenterX, this.gaugeCenterY);
                        } else {
                            ctx.fillText('Expected', this.gaugeCenterX, this.gaugeCenterY + 5);
                        }
                        ctx.closePath();
                        var fontSize = this.fontSize * 1.3;
                        ctx.beginPath();
                        ctx.font = "bold " + fontSize + "px " + this.fontStyle;
                        ctx.textAlign = "center";
                        ctx.textBaseline = "top";
                        var target_value = numFormatter(quarter_divide * this.limits.slice(-1)[0], this.decimalPrecision);
                        if (screen.width>=1440){
                            ctx.fillText(target_value, this.gaugeCenterX, this.gaugeCenterY);
                        } else {
                            ctx.fillText(target_value, this.gaugeCenterX, this.gaugeCenterY + 5);
                        }
                        ctx.closePath();
                    break;
                    case 't_year':
                        var today = new Date();
                        var year_start = new Date(today.getFullYear(), 0, 1);
                        var diffTime = Math.abs(today - year_start);
                        var diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
                        // assume every year has 365 days
                        var maximum_days = diffDays > 365? diffDays: 365;
                        var year_divide = diffDays / maximum_days;
                        // get the angle of the arrow
                        var date_angle = year_divide * Math.PI;
                        // draw arrow
                        var coord = this.getCoordOnCircle(radius * 0.8, date_angle);
                        var arrowPoint = {
                            x: this.gaugeCenterX - coord.x + 2,
                            y: this.gaugeCenterY - coord.y + 2
                        };
                        var fontSize = this.fontSize;
                        ctx.beginPath();
                        ctx.moveTo(arrowPoint.x, arrowPoint.y);
                        coord = this.getCoordOnCircle(radius * 0.2, date_angle + arrowAngle);
                        ctx.lineTo(arrowPoint.x + coord.x, arrowPoint.y + coord.y);
                        coord = this.getCoordOnCircle(radius * 0.2, date_angle - arrowAngle);
                        ctx.lineTo(arrowPoint.x + coord.x, arrowPoint.y + coord.y);
                        ctx.fill();
                        ctx.closePath();
                        // draw the up to date target label and value
                        var fontSize = this.fontSize
                        ctx.beginPath();
                        ctx.font = "bold " + fontSize + "px " + this.fontStyle;
                        ctx.textAlign = "center";
                        ctx.textBaseline = "bottom";
                        if (screen.width>=1440){
                            ctx.fillText('Expected', this.gaugeCenterX, this.gaugeCenterY);
                        } else {
                            ctx.fillText('Expected', this.gaugeCenterX, this.gaugeCenterY + 5);
                        }
                        ctx.closePath();
                        var fontSize = this.fontSize * 1.3;
                        ctx.beginPath();
                        ctx.font = "bold " + fontSize + "px " + this.fontStyle;
                        ctx.textAlign = "center";
                        ctx.textBaseline = "top";
                        var target_value = numFormatter(year_divide * this.limits.slice(-1)[0], this.decimalPrecision);
                        if (screen.width>=1440){
                            ctx.fillText(target_value, this.gaugeCenterX, this.gaugeCenterY);
                        } else {
                            ctx.fillText(target_value, this.gaugeCenterX, this.gaugeCenterY + 5);
                        }
                        ctx.closePath();
                    break;
                }
                break;
	    }
	};
	GaugeChartHelper.prototype.animateArrow = function() {
		var stepCount = 1;
		var animateTimeout = 1;
		if (this.arrowAnimation) {
	        var stepCount = 30;
		    var animateTimeout = 300;
		};
		var gaugeValue = this.data.value - this.minValue;
		var step = gaugeValue / stepCount;
		var i = 0;
		var currentValue = this.minValue;
		// only render the arrow when the gauge has non-zero limits
		var empty = true;
        for(var i=0;i < this.limits.length; i++){
            if(this.limits[i] !== 0) {
                empty = false;
                break;
            }
        }
        if (!empty){
            this.renderSmallValueArrow(gaugeValue);
        }
        // disable the animation
//		var interval = setInterval(function() {
//			i++;
//			if (stepCount > 1){
//			    this.clearValueArrow(currentValue);
//			}
//			if (i > stepCount) {
//				clearInterval(interval);
//				this.renderValueArrow();
//			} else {
//				currentValue += step;
//				var empty = true;
//                for(var i=0;i < this.limits.length; i++){
//                    if(this.limits[i] !== 0) {
//                        empty = false;
//                        break;
//                    }
//                }
//                if (!empty){
//				    this.renderSmallValueArrow(currentValue);
//                }
//			}
//		}.bind(this), animateTimeout / stepCount);
	};
	Chart.defaults.tsgauge = {
		animation: {
		    duration: 0,
			animateRotate: true,
			animateScale: false
		},
		rotation: Math.PI,
		circumference: Math.PI,
		legend: {
			display: false
		},
		scales: {},
		arrowColor: "#444"
	};
	Chart.controllers.tsgauge = Chart.controllers.doughnut.extend({
		initialize: function(chart) {
			var gaugeHelper = this.gaugeHelper = new GaugeChartHelper();
			gaugeHelper.setup(chart, chart.config);
			gaugeHelper.applyGaugeConfig(chart.config);
			chart.config.options.animation.onComplete = function(chartElement) {
				gaugeHelper.updateGaugeDimensions();
				gaugeHelper.animateArrow();
			};
			Chart.controllers.doughnut.prototype.initialize.apply(this, arguments);
		},
		draw: function() {
			Chart.controllers.doughnut.prototype.draw.apply(this, arguments);
			var gaugeHelper = this.gaugeHelper;
			gaugeHelper.updateGaugeDimensions();
			gaugeHelper.renderValueLabel();
			if (gaugeHelper.showMarkers) {
				gaugeHelper.renderLimits();
			}
			if (gaugeHelper.arrowAnimation) {
			    gaugeHelper.renderSmallValueArrow(gaugeHelper.minValue);
			};
		}
	});
})();